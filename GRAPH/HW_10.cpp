// Построение минимального остова (min spaning tree )
// Алгоритм Краскала
/*
  Алгоритм Краскала изначально помещает каждую вершину в своё дерево,
  а затем постепенно объединяет эти деревья, объединяя на каждой итерации два
  некоторых дерева некоторым ребром. Перед началом выполнения алгоритма
  все рёбра сортируются по весу (в порядке неубывания).
  Затем начинается процесс объединения: перебираются все рёбра от первого
  до последнего (в порядке сортировки), и если у текущего ребра его концы
  принадлежат разным поддеревьям, то эти поддеревья объединяются,
  а ребро добавляется к ответу. По окончании перебора всех рёбер все вершины
  окажутся принадлежащими одному поддереву, и ответ найден
*/
#include <iostream>
#include <vector>
#include <algorithm> // для функции sort

using namespace std;

/*
В основной программе:
int m; //количество ребер
int n; //число вершин
vector < pair < int, pair<int,int> > > g(m); // список ребер
                                              //вес, вершина 1, вершина 2
vector < pair<int,int> > res;  //список ребер в полученном остове
*/

// возвращает суммарный вес остова
int MSP(vector< pair< int, pair<int,int > > > &g, int m, int n,vector <pair<int,int > > &res)
{
  vector<int> compn(n);  // compn[i] = номер компоненты вершины i
  int cost = 0;  //ответ - суммарный вес остова

  sort (g.begin(), g.end());  //сортируем список ребер по весу
  for (int i=0; i<n; ++i)
	compn[i] = i;   // вначале каждая вершина в отдельной компоненте
  for (int i=0; i<m; ++i)   // выбираем очередное минимальное ребро
  {
	int a = g[i].second.first;    //первая вершина ребра
        int b = g[i].second.second;   //вторая вершина ребра
        int w = g[i].first;           //вес ребра
	if (compn[a] != compn[b]) //если вершины a и b в разных компонентах
	{                             //значит ребро еще не включали в остов
		cost += w;            //суммируем к весу остова
		res.push_back (make_pair (a, b)); //добавляем ребро в ответ
		int old_comp = compn[b]; //номер компоненты вершины b
                int new_comp = compn[a]; // и номер компоненты вершины а

		for (int j=0; j<n; ++j) // все вершины с компонентой old_comp
                                        // переносим в компоненту new_comp
			if (compn[j] == old_comp)
				compn[j] = new_comp ;
	}
  }
  return cost;
}
int main(int argc, char** argv) {
	return 0;
}
