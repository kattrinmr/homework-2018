#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <algorithm>  // для reverse
#include <queue>

//#include <stdio.h>

using namespace std;

vector <vector <int> > g;  // Граф в виде списка смежности
int N;
vector <int> used;   // Вектор признака посещённости вершин
vector <int> parent; // Вектор предков
vector <int> dist;   // Вектор расстояний (количество ребер до вершины от стартовой)

/*=================================================================
Читаем граф из файла: сначала число вершин, а потом в каждой строке
по 2 смежные вершины, например,
12
1 5
11 9
...
Передаётся в функцию имя файла fname и
orient- ориентированный граф или нет 
*/
int getGraf(string fname, bool orient){
	int v1, v2;
	
	FILE *file; // создаем переменную типа FILE
	file = fopen(fname.c_str(), "r"); // открываем файл
									  // c-string - string переводим в тип char*
									  // "r"- открываем файл для чтения
	fscanf(file, "%d", &N); // читаем из файла количество вершин
							// "%d"- прочитанное перевести в тип int
							// %f- float, %s- string
	//cout << N << endl; 
	//заполняем вектор g пустыми векторами типа int!!!
	//если бы заранее знали N, то можно было бы vector<vector<int>> g(n);
	for( int i=0; i<N; i++){	g.push_back(vector <int>());	}; //способ инициации вектора векторов
	// читаем остальные строки
	while (fscanf (file, "%d %d", &v1, &v2) != EOF ){ //пока не получим End Of File читаем два int 
													  // из каждой строки файла
		v1--;  // работаем от 0, поэтому от номеров вершин отнимаем 1
		v2--;
		g[v1].push_back(v2);  //добавляем в список вершины V1 вершину V2
		if( !orient) g[v2].push_back(v1); //и наоборот если неориентированный
		//cout << v1 << " " << v2 << endl;
	}
	//file.close();
/*	

	другой способ чтения из файла через потоки
	ifstream file(fname.c_str());
	file >> N;
	
	while (file >> v1 >> v2){
		for( int i=0; i<N; i++){	g.push_back(vector <int>());	}
	}
	file.close(); 
*/
	return 0;
}
//===================================================================
/*
                Обход графа в ширину BFS
Суть алгоритма заключается в том, чтобы просматривать сначала стартовую 
вершину 0, затем те вершины, которые удалены от нее на расстояние 1 
и так далее слоями: затем просматриваем вершины, которые удалены на расстояние d, 
далее d+1. Для этого в алгоритме используется очередь Q, в которую сначала заносится 
стартовая вершина 0. Затем повторяем следующие итерации: пока очередь не пуста, 
достаем из ее головы очередную вершину и просматриваем всех соседей этой вершины, 
и если какие-то из них еще не помещены в очередь, то помещаем их в конец очереди. 
При таком обходе, когда очередь станет пуста, все вершины будут просмотрены, 
причем в порядке увеличения расстояния от стартовой вершины. 
Длины кратчайших путей считаются в процессе алгоритма при помощи массива расстояний dist[] и 
массива предков вершин parent[].
*/
void BFS( int start){
	queue<int> q; // Очередь вершин 

	q.push (start); //Добавляем стартовую вершину 
	used[start] = true; //Стартовую вершину считаем посещенной 
	parent[start] = -1; //У стартовой вершины нет предка 
	while (!q.empty()) { //Пока очередь не пуста 
		int v = q.front(); //Извлекаем из начала очереди вершину 
		q.pop(); //удаляем извлеченную вершину 
		for (size_t i=0; i <g[v].size(); ++i) { //Просмотр всех смежных вершин
			int to = g[v][i]; 					//to = потомок 
			if (used[to] == 0){ //Если вершина не посещена, 
				used[to] = true; //посещаем ее 
				q.push (to);     //и добавляем к концу очереди 
				dist[to] = dist[v] + 1;//Считаем расстояние до вершины 
				parent[to] = v;       //Запоминаем предка 
			} 
		}
	}
}

//==========================================================================
int main(int argc, char** argv) {
	getGraf("graf1.txt", false);   //читаем неориентированный граф в список смежности
	for(int i=0; i<N; i++){  //инициализируем вектора
		used.push_back(0);
		parent.push_back(-1);
		dist.push_back(0);
}

	BFS(0);
	// Выводим кратчайший путь (по кол-ву ребер) до вершины 9 из 1
	int to = 9-1;
	if (used[to] == 0) // не посещали => to - в другой компоенте связности
		cout << "No path!";
	else {
		vector<int> path;
		for (int v = to; v! = -1; v = parent[v])
			path.push_back (v);
		reverse (path.begin(), path.end());
		cout << "Path: ";
		for (size_t i=0; i < path.size(); ++i)
			cout << path[i] + 1 << " ";
		cout << endl;
}
	system("pause");
	return 0;
}
